## 1、 自我介绍
 面试官你好，我叫xxx，来自xxx。本科xxx专业毕业，从事web前端开发三年多了。在自研公司和外包公司都工作过。在这里期间开发过很多不同类型的项目，比如pc端门户网站、后台管理系统、移动端电商项目、（跨端RN技术开发的移动端..）等项目，使用了技术也非常广泛，从jquery到现在的React、vue框架开发整体技术都没有什么问题，现在最近开发的是使用vue开发的pc端电商项目。如果可以的话，我可以给你介绍一下我最近开发的项目。

## 2、 介绍项目
* 是一个什么项目？
* 你负责了什么模块？
* 使用了什么技术？
* 遇到什么问题？怎么解决的？

* 心意商城
* 是一个主打礼品的电商项目，价格比较实惠。项目分为PC端和移动端，我主要负责移动端。
* 整个项目耗时3个月，后期也在不断维护。主要功能都是我开发的，包括主页，分类，商品详情、购物车等模块。
* 登录功能
	* 发送验证码这里主要将手机号发送给后台，后台会将调用第三方SDK来发送验证码到手机上
	* 当用户登录时，我们再将用户的输入的验证码发送到后台去验证，通过才能登录
	* 这里为了解决跨域都是使用jsonp
* 搜索功能
	* 一上来有一个搜索功能，点击使用v-show来切换显示。
	* 而里面的热门搜索通过发送请求得到热门搜索数据。进而保存在localStorage中，这样下次用户访问就无须在请求了
* 轮播图和滑屏使用的是mint-ui和better-scroll完成的。
	* 这里面better-scroll有个问题
	* xxx
* 基本布局使用flex 和 rem。
	* flex进行等分布局非常方便好用
* 商品列表都会封装组件从而复用
* 分类页面
	* 使用better-scroll做的侧边导航
	* 数据是点击时动态获取，这里主要做了图片懒加载
* 这种项目基本上包含了市面上绝大部分功能，这种项目开发对于我来讲基本没问题。

## 3、 技能点 - HTML/CSS
* BFC
* flex
	* flex是弹性盒模型
	* 我开发中主要使用它来做等分布局和垂直水平居中。
	* 等分布局：
	* 垂直水平居中：
* rem
	* 
* 1px像素问题
	* css 1px 放在移动端 是 2px 3px 的物理像素
	* 所以要实现 1px 物理像素，得根据像素比来进行缩放(@media)
* 事件点透
	* 点击时先触发touch，300ms再触发click。
	* 解决：fastclick 
	* 原理：禁止click事件 ？？
* 圣杯布局和双飞翼布局

## 4、 技能点 - JS
* 原型
	* 原型主要有两个属性：
		* prototype
		* __proto__
	* 为了更好的称呼，prototype叫做显示原型属性。__proto__叫做隐式原型属性。
	* 所有函数都有显示原型属性（箭头函数没有），它的值叫做原型对象。原型对象上有constructor属性，指向函数本身。上面有__proto__指向Object.prototype
	* 所有对象都有隐式原型属性。它的值指向其对应的构造函数的显示原型。
	* 在原型中有两个比较特殊的：
		* Object.prototype.__proto__ = null 这是原型链的尽头
		* Function.prototype === Function.__proto__ 
	* 原型链：
		* 由隐式原型组成的链状结构时原型链。
		* 作用：是对象查找属性/方法的规则
		* 具体规则为
			* 先在自身属性上找，找到了返回
			* 找不到，沿着隐式原型属性接着找，找到了返回
			* 一层层找，直到来到Object.prototype.__proto__，这是原型链的尽头
			* 在没有就是undefined
	* 原型主要是用来实现继承的，说白了就是实例对象继承父类的方法和属性。 这种方式一般是构造函数+原型组合继承的方法使用。但是在开发中用的不是很多
	* 在开发中一般我们直接使用es6的class语法，更加直观简单。不过注意需要通过babel编译后再上线就好了~。
	* es6 class语法一般我们在开发react用的多一些，这是react组件的用法。

* 闭包
	* 通过chrome开发者工具调试查看，闭包是一个包含被引用局部变量的（closure）对象，存在于嵌套的内部函数中。是内部函数的一部分
	* 作用：
		* 延长局部变量的生命周期
		* 让函数外部能操作读写函数内部的数据
	* 缺点是：容易造成内存泄漏
	* 解决：及时释放内部函数，让其成为垃圾对象，闭包会和内部函数一起死亡
	* 在开发中一般不会刻意使用闭包，而是写着写着自然就出来了，比如：在使用高阶函数（执行函数返回值也是函数）时，就很容易产生闭包。
		* 高阶函数一般在React中定义高阶组件时使用。
		* 高阶组件本质上是一个函数，接收一个组件作为参数，返回值是一个新组件

* 缓存机制
	* 缓存分为强制缓存和协商缓存。
	* 强制缓存：
		* cache-control  http 1.1
		* expires http 1.0
	* 协商缓存：
		* 分为两部分：位于请求头和位于响应头
		* 请求头：
			* if-none-match (与上一次发送过的etag值一样)
			* if-modified-since (与上一次发送过的last-modified值一样)
		* 响应头
			* etag 代表文件内容的标识
			* last-modified 代表文件最近一次的修改时间
	* 整体工作流程
		* 浏览器会先查看强制缓存。如果是http 1.1协议看cache-control，如果是http 1.0协议看expires（主流是1.1），看有限期有没有过期。如果没有过期，浏览器不会发送请求，直接读取缓存数据。如果过期了，在看协商缓存
		* 一旦走协商缓存，浏览器就会发送请求到服务器上，服务器将接受的if-none-match和etag进行对比，相同说明文件没有改变，返回状态码304走协商缓存。不相同说明文件变化了，需要返回新的资源，状态码为200(此时不走协商缓存)。 如果if-none-match没有，则看if-modified-since和last-modified进行对比，相同说明文件没有改变，返回状态码304走协商缓存。不相同说明文件变化了，需要返回新的资源，状态码为200(此时不走协商缓存)。
	* 使用缓存，能有效的减少浏览器的重复请求，从而减轻服务器压力，并且走缓存速度快的原因，也能提升页面渲染速度和性能。

* 浏览器存储
	* cookie / session
		* cookie 
			* 一个域名下，cookie大小4kb左右，数量20个左右
			* 一般使用较少，除非结合session使用
		* session
			* 存储容量较大，在服务器端，会产生一个cookie
			* 一般用于登录缓存用户会话状态
		* 而我们项目使用JWT技术保存用户信息，存在localstorage中，这样每次用户初次访问时，从本地读取localStorage数据就能知道有没有登录过
			* JWT技术： JSON WEB TOKEN 详情掘金搜文章，可直接说不是很了解，直接使用公司的库就生成了然后存起来

	* sessionStorage / localStorage
		* 特点：离线存储，容量较大4mb左右
		* sessionStorage：浏览器本地的会话存储，关闭浏览器会被清空，一般用的少
		* localStorage：浏览器本地的永久存储
			* 用的较多，用它来存储用户JWT和其他用户信息，或者一些经常不变的信息
			* 这里引出一个思考，其实经常不变的，写死不太好，因为可能变化，这个时候如果用服务器渲染可能更好
			
	* webSQL / indexDB
		* 容量巨大，很大。是以数据库方式存储数据，读写速度快
		* 缺点就是兼容性问题严重。
			* webSQL兼容性更好，但是被废弃了
			* indexDB兼容性很差，但是体验更好
		* 所以可以使用一个库 localforage。 它自动做兼容性处理，如果支持就使用，不支持就用localstorage
	* PWA
		* service work / cache
		* 浏览器离线可访问技术，正常网页断网啥也看不了，而PWA能保证能运行。
		* 因为兼容性问题，所以项目中还未使用，但是是一个很好提升用户离线访问体验的一种技术

* 事件机制
	* 捕获 - 目标 - 冒泡
* 事件轮询机制
	* 异步代码的执行机制
	* 主线程会从上到下依次执行全局所有代码
      当遇到定时器时，会将定时器设置的回调函数和时间交给浏览器定时器管理模块管理（开启分线程），
      浏览器定时器管理模块会开始计时，当到点了，将回调函数添加到回调队列的最后面
      当遇到dom事件时，会将dom元素、事件名、回调函数交给浏览器DOM事件管理模块管理
      览器DOM事件管理模块首先给dom元素绑定事件，一旦事件触发了，将回调函数添加到回调队列的最后面
      当主线程将全局代码全部执行完毕后，才会开启事件轮询：
        将回调队列中回调函数依次取出，同步执行。执行完过一会再访问回调队列中回调函数依次取出，同步执行。
        一直反复做这个事，一个死循环
	* 异步代码执行不止看事件轮询，还需要探讨宏任务、微任务
		* 微任务：Promise.then()/catch()/finally()
		* 宏任务：定时器
		* 先执行微任务，直到所有微任务执行完，才执行宏任务，执行完一个宏任务，继续执行微任务，执行完所有微任务，再执行下一个宏任务，以此类推

* 从地址栏输入url 地址到页面渲染经历的过程
	* DNS解析/查询
		* 将域名地址解析为ip地址
		* 具体如下： 
			* 浏览器缓存
			* 计算机系统缓存 
			* 路由器缓存
			* ISP（网络运营商：如移动、电信） DNS 缓存
			* 递归搜索
				* 如网址是： www.a.b.com
				* 先找.com --> b.com --> a.b.com
	* TCP连接：TCP三次握手
		* tcp三次握手的内容
		* 为什么要进行三次握手
	* 走缓存
		* 强制缓存
	* 发送请求：请求报文
	* 返回响应：响应报文
		* 协商缓存
	* 渲染页面
		* html 
		* css
		* js
		* render tree
		* layout
		* render
	* 断开连接：TCP四次挥手（请求、响应）
		* 为什么需要4次挥手

* 响应状态码
	* 1xx: 请求还需要进一步处理
	* 2xx： 请求成功  200
	* 3xx：请求资源重定向
		* 302 请求资源重定向到其他网址
		* 304 请求资源重定向浏览器缓存中
	* 4xx 请求资源未找到  404
	* 5xx 服务器内部错误  500

* 谈谈es
	* es5
		* 严格模式，保证代码能严格稳定运行。
			* 通常不自己写，通过babel编译后实际上代码会加上严格模式
			* 它为了保证代码更加严格、稳定运行
		* Object.create
			* 它以指定对象为原型创建新对象，用来实现对象的继承
			* 除了这种方法，还有构造函数+原型、class等方式实现继承
		* Object.defineProperties()
			* 用来定义对象属性的属性，通常用来做数据劫持
			* 这个在vue的双向数据绑定原理中使用了
		* 函数的bind方法
			* call/apply/bind的区别
			* this指向
	* es6
		* 像简单的let/const/.../解构赋值等简单语法就不说了，我来说说一些更加复杂又有意思语法：
		* 箭头函数
			* 她就是为了解决我们开发中的一个问题而诞生的，我们开发中老是想在内层函数得到函数的this，过去还得定义一个额外变量去获取，现在箭头函数直接搞定
			* 箭头函数没有自己的this，它的this指向离它最近一层包裹它的函数的this
				* 这里如果之前没有总结this，就要总结this
		* promise
			* 异步编程解决方案之一，在开发中通常都需要给异步代码包一层promise
			* promise内部有三种状态：
				* pending初始化
				* resolved / fulfilled 成功
				* rejected 失败
			* new Promise默认是初始化状态，当调用resolve会改为成功，调用reject会改为失败
			* 最后还可以将宏任务、微任务
		* async函数最终解决异步问题
		* set/map容器。使用set可以去重
		* Object.assign方法浅度克隆，自定义深度克隆
			* 深度克隆对于React中的state是有意义的
			* React性能优化会进行state和props的比较，如果引用一样会导致判断不准确，需要必须创建一个新对象，此时深度克隆就很有必要了
	* es7
		* 幂运算 **
		* Array.prototype.includes 判断数组是否包含某个值
	* es8
		* async函数是es8的
	* es9
		* Object.keys
		* Object.values
	* es10
		* 动态import
			* 这个用于vue/react 组件懒加载

* webpack
	* 5个核心概念
		* entry
		* output
		* loader
		* plugins
		* mode
	* 进阶优化配置
		* tree shaking
		* code splitting
		* 缓存
		* 懒加载
		* babel优化
		* polyfill
		* happypack 多进程
		* dll 提前打包
		* ...
	* loader原理
	* plugin原理
	* webpack原理		

* node.js
	* 是一个js运行环境，包含服务器的必要模块：http、fs等
	* 优点：
		* 事件轮询机制
		* 异步非阻塞
	* 应用：
		* 处理高并发
		* BFF（backends for frontends） 中间件，为前端统一接口
	* 使用：
		* express / koa
		* mongoose / mysql / redis
		* ...

* 性能优化
	* 编写代码角度
	* 框架角度
	* webpack角度

* 常见的兼容性问题

* 安全性问题
	* https://github.com/xiaomuzhu/front-end-interview/blob/master/docs/guide/security.md
	* XSS：跨站脚本攻击
		* 问题：在写评论的地方，写script标签，导致页面显示时加载了一个非法的js
		* 解决：对所有用户输入转义处理
	* CSRF：跨站请求伪造
		* 问题：通过访问非法地址，截取用户的cookie，从而通过cookie伪造用户登录
		* 解决： 给cookie设置httpOnly，让cookie只能在服务端获取， 设置cookie的同源检查等
	* SQL注入
		* 问题：通过输入用户名密码时，写sql语句
		* 解决：转义处理
	
* vue

* react
	* https://github.com/xiaomuzhu/front-end-interview/blob/master/docs/guide/react.md

* 手写代码
	* 深度克隆
	* promise